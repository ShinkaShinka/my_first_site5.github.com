<!DOCTYPE html>
<html lang="ru">
<head>
	<meta charset="utf-8">
	<title>Оптимизация 3D-моделей</title>
	<link rel="stylesheet" type="text/css" href="style.css">
	<link rel="shortcut icon" href="site_icon.ico">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>


<body>
	<header>
		<div class="navigation">
			<a href="../contactInfo/info.html" class="brand">О нас</a>
			<h1 class="sitename">Оптимизация 3D-моделей</h1>
			<a href="../main/mainPage.html" style="font-size: 2vw;">На главную ></a>
		</div>
	</header>
	<HR>

	<div class="content">
		<div class="content_center">
			<h1 style="font-size: 2vw;">Оптимизация 3D-моделей</h1>
		</div>

		<div style="font-size: 1.3vw; background: #212742; height: 1.8vw; text-align: left;">
			<a style="vertical-align: middle; margin-left: 0.5vw;" href="https://www.intel.com/content/www/us/en/support/ru-banner-inside.html">Автор оригинала: Eskil Steenberg</a>
		</div>

		<div style="font-size: 2vw; margin-top: 25px; text-align: center;">Для оптимизации 3D-моделей недостаточно считать полигоны</div>

		<div class="content_center">
			<img style="max-width: 100%; width: 70%; height: 70%; margin-top: 25px; cursor: zoom-in" src="0.png" alt="Image">
		</div>
		<p>Разобравшись с основами процесса рендеринга мешей, вы сможете применять различные техники для оптимизации скорости рендеринга.</p>

		<h3>Введение:</h3>
		<p>Сколько полигонов мне можно использовать? Это очень частый вопрос, который задают художники при создании моделей для рендеринга в реальном времени. На этот вопрос сложно ответить, потому что дело не только в цифрах.</p>
		<p>Я начинал карьеру как 3D-художник ещё в эпоху первой PlayStation, а позже стал программистом графики. Хотел бы я прочитать эту статью перед тем, как впервые начал создавать 3D-модели для игр. Рассмотренные в ней фундаментальные основы пригодятся многим художникам. Хотя бОльшая часть информации из этой статьи не повлияет значительно на продуктивность вашей ежедневной работы, она даст вам базовое понимание того, как графическая карта (graphics processing unit, GPU) отрисовывает создаваемые вами меши.</p>
		<p>От количества полигонов в меше обычно зависит скорость его рендеринга. Однако несмотря на то, что количество полигонов часто коррелирует с частотой кадров в секунду (FPS), вы можете обнаружить, что даже после снижения количества полигонов меш по-прежнему рендерится медленно. Но поняв, как рендерятся меши в целом, вы сможете применить набор техник для повышения скорости рендеринга.</p>

		<h3>Как представлены данные полигонов:</h3>
		<p>Чтобы понять, как GPU рисует полигоны, нужно сначала рассмотреть структуру данных, используемую для описания полигонов. Полигон состоит из набора точек, называемых вершинами, и ссылок. Вершины часто хранятся как массивы значений, например подобно рисунку 1.</p>
		<div>
			<img style="max-width: 100%; height: auto; margin-top:25px; cursor: zoom-in" src="1.png" alt="Image">
		</div>
		<p style="font-style: italic; text-align: center;">Рисунок 1. Массив значений простого полигона.</p>

		<div style="text-align: center;">
			<img style="max-width: 100%; width: 70%; height: 70%; margin-top: 25px; cursor: zoom-in" src="2.png" alt="Image">
		</div>
		<p style="font-style: italic; text-align: center;">Рисунок 2. Массив ссылок на вершины.</p>
		<p>Эти вершины, соединённые вместе, образуют два полигона. Заметьте, что два треугольника, в каждом из которых по три угла, можно описать четырьмя вершинами, потому что вершины 1 и 2 используются в обоих треугольниках. Чтобы эти данные мог обработать GPU, предполагается, что каждый полигон является треугольным. GPU ожидают, что вы работаете с треугольниками, потому что они предназначены именно для их отрисовки. Если вам нужно отрисовать полигоны с другим количеством вершин, то необходимо приложение, разделяющее их на треугольники перед отрисовкой в GPU. Например, если вы создаёте куб из шести полигонов, каждый из которых имеет по четыре стороны, то это не более эффективно, чем создание куба из 12 полигонов, состоящих из трёх сторон; именно эти треугольники будет отрисовывать GPU. Запомните правило: считать нужно не полигоны, а треугольники.</p>
		<p>Использованные в предыдущем примере данные вершин являются трёхмерными, но это необязательно. Вам может быть достаточно и двух измерений, но часто необходимо хранить и другие данные, например, UV-координаты для текстур и нормали для освещения.</p>

		<h3>Отрисовка полигона:</h3>
		<p>При отрисовке полигона GPU первым делом определяет, где нужно рисовать полигон. Для этого он вычисляет позицию на экране, где должны находиться три вершины. Эта операция называется преобразованием (transform). Эти вычисления в GPU выполняет небольшая программа под названием «вершинный шейдер».</p>
		<p>Вершинный шейдер часто выполняет и другие типы операций, например, обработку анимаций. После вычисления позиций всех трёх вершин полигона GPU вычисляет, какие пиксели находятся в этом треугольнике, а затем начинает заполнять эти пиксели с помощью ещё одной маленькой программы под названием «фрагментный шейдер» (fragment shader). Фрагментный шейдер обычно выполняется один раз на пиксель. Однако в некоторых редких случаях он может выполняться несколько раз на пиксель, например, для улучшения сглаживания (антиалиасинга). Фрагментные шейдеры часто называются пиксельными шейдерами, потому что в большинстве случаев фрагменты соответствуют пикселям (см. рисунок 3).</p>
		<div style="text-align: center;">
			<img style="max-width: 100%; width: 80%; height: 80%; margin-top: 25px; cursor: zoom-in" src="3.png" alt="Image">
		</div>
		<p style="font-style: italic; text-align: center;">Рисунок 3. Один полигон, отрисованный на экране.</p>
		<p>На рисунке 4 показан порядок действий, выполняемый GPU при отрисовке полигона.</p>
		<div style="text-align: center;">
			<img style="max-width: 100%; width: 80%; height: 80%; margin-top: 25px; cursor: zoom-in" src="4.png" alt="Image">
		</div>
		<p style="font-style: italic; text-align: center;">Рисунок 4. Порядок действий GPU, отрисовывающего полигон.</p>
		<p>Если разделить треугольник на два и отрисовать оба треугольника (см. рисунок 5), то порядок действий будет соответствовать рисунку 6.</p>
		<div style="text-align: center;">
			<img style="max-width: 100%; width: 80%; height: 80%; margin-top: 25px; cursor: zoom-in" src="5.png" alt="Image">
		</div>
		<p style="font-style: italic; text-align: center;">Рисунок 5. Разделение полигона на два.</p>
		<div style="text-align: center;">
			<img style="max-width: 100%; width: 90%; height: 90%; margin-top: 25px; cursor: zoom-in" src="6.png" alt="Image">
		</div>
		<p style="font-style: italic; text-align: center;">Рисунок 6. Порядок действий GPU, рисующего два полигона.</p>
		<p>В этом случае требуется в два раза больше преобразований и подготовок, но поскольку количество пикселей осталось таким же, операции не нужно растеризировать дополнительные пиксели. Это показывает, что удваивание количества полигонов необязательно удваивает время рендеринга.</p>

		<h3>Использование кэша вершин:</h3>
		<p>Если посмотреть на два полигона из предыдущего примера, то можно увидеть, что у них есть две общие вершины. Можно предположить, что эти вершины придётся вычислять дважды, но механизм под названием «кэш вершин» (vertex cache) позволяет использовать результаты вычислений повторно. Результаты вычислений вершинного шейдера для повторного применения сохраняются в кэш — небольшую область памяти, содержащую несколько последних вершин. Порядок действий при отрисовке двух полигонов с использованием кэша вершин показан на рисунке 7.</p>
		<div style="text-align: center;">
			<img style="max-width: 100%; width: 90%; height: 90%; margin-top: 25px; cursor: zoom-in" src="7.png" alt="Image">
		</div>
		<p style="font-style: italic; text-align: center;">Рисунок 7. Отрисовка двух полигонов с использованием кэша вершин.</p>
		<p>Благодаря кэшу вершин можно отрисовать два полигона почти так же быстро, как один, если они имеют общие вершины.</p>

		<h3>Разбираемся с параметрами вершин:</h3>
		<p>Чтобы вершину можно было использовать повторно, при каждом использовании она должна быть неизменной. Разумеется, той же должна оставаться позиция, но и другие параметры тоже не должны меняться. Передаваемые вершине параметры зависят от используемого движка. Вот два широко распространённых параметра:</p>
		<ul>
			<li>Текстурные координаты
			<li>Нормали
		</ul>
		<p>При UV-наложении на 3D-объект любой создаваемый шов будет означать, что вершины вдоль шва не могут быть общими. Поэтому в общем случае стоит избегать швов (см. рисунок 8).</p>
		<div style="text-align: center;">
			<img style="max-width: 100%; width: 90%; height: 90%; margin-top: 25px; cursor: zoom-in" src="8.png" alt="Image">
		</div>
		<p style="font-style: italic; text-align: center;">Рисунок 8. UV-наложение швов текстуры.</p>
		<p>Для правильного освещения поверхности каждая вершина обычно хранит нормаль — вектор, направленный от поверхности. Благодаря тому, что все полигоны с общей вершиной задаются одной нормалью, их форма кажется плавной. Это называется плавным затенением (smooth shading). Если каждый треугольник имеет собственные нормали, то рёбра между полигонами становятся выраженными, а поверхность кажется плоской. Поэтому это и называется плоским затенением (flat shaded). На рисунке 9 показаны два одинаковых меша, один со сглаженным затенением, а второй — с плоским.</p>
		<div style="text-align: center;">
			<img style="max-width: 100%; width: 90%; height: 90%; margin-top: 25px; cursor: zoom-in" src="9.png" alt="Image">
		</div>
		<p style="font-style: italic; text-align: center;">Рисунок 9. Сравнение сглаженного с плоским затенением.</p>
		<p>Эта геометрия со сглаженным затенением состоит из 18 треугольников и имеет 16 общих вершин. Для плоского затенения 18 треугольников нужно 54 (18 x 3) вершины, потому что ни одна из вершин не является общей. Даже если два меша имеют одинаковое количество полигонов, скорость их отрисовки всё равно будет разной.</p>
		<h3>Важность формы:</h3>
		<p>GPU быстро работают в основном потому, что они могут выполнять множество операций параллельно. В маркетинговых материалах GPU часто делается упор на количество их конвейеров (pipeline), определяющих количество операций, которые может выполнять GPU одновременно. Когда GPU отрисовывает полигон, он отдаёт множеству конвейеров задание заполнять квадраты пикселей. Обычно это квадрат размером восемь на восемь пикселей. GPU продолжает это делать, пока не будут заполнены все пиксели. Очевидно, что треугольники не являются квадратами, поэтому некоторые пиксели квадрата окажутся внутри треугольника, а другие снаружи. Оборудование работает со всеми пикселями квадрата, даже с теми, которые находятся за пределами треугольника. После вычисления всех вершин в квадрате оборудование отбрасывает пиксели за пределами треугольника.</p>
		<p>На рисунке 10 показан треугольник, для отрисовки которого требуется три квадрата (тайла). Большинство вычисленных пикселей (голубые) используется, а показанные красным выходят за границы треугольника и будут отброшены.</p>
		<div style="text-align: center;">
			<img style="max-width: 100%; width: 15%; height: 15%; margin-top: 25px; cursor: zoom-in" src="10.png" alt="Image">
		</div>
		<p style="font-style: italic; text-align: center;">Рисунок 10. Три тайла для отрисовки треугольника.</p>
		<p>Полигон на рисунке 11 с точно таким же количеством пикселей, но растянутый, требует для заполнения большего количества тайлов; бОльшая часть результатов работы в каждом тайле (красная область) будет отброшена.</p>
		<div style="text-align: center;">
			<img style="max-width: 100%; width: 45%; height: 45%; margin-top: 25px; cursor: zoom-in" src="11.png" alt="Image">
		</div>
		<p style="font-style: italic; text-align: center;">Рисунок 11. Заполнение тайлов в растянутом изображении.</p>
		<p>Количество отрисовываемых пикселей — это только один из факторов. Так же важна форма полигона. Для повышения эффективности старайтесь избегать длинных, узких полигонов и отдавайте предпочтение треугольникам с примерно равной длиной сторон, углы которого близки к 60 градусам. Две плоские поверхности на рисунке 12 триангулированы двумя разными способами, но при рендеринге выглядят одинаково.</p>
		<div style="text-align: center;">
			<img style="max-width: 100%; width: 85%; height: 85%; margin-top: 25px; cursor: zoom-in" src="12.png" alt="Image">
		</div>
		<p style="font-style: italic; text-align: center;">Рисунок 12. Поверхности, триангулированные двумя разными способами.</p>
		<p>Они имеют абсолютно одинаковое количество полигонов и пикселей, но так как поверхность левого имеет более длинные, узкие полигоны, чем у правого, его рендеринг будет более медленным.</p>

		<h3>Перерисовка:</h3>
		<p>Для отрисовки шестилучевой звезды можно создать меш из 10 полигонов или нарисовать ту же фигуру всего из двух полигонов, как показано на рисунке 13.</p>
		<div style="text-align: center;">
			<img style="max-width: 100%; width: 85%; height: 85%; margin-top: 25px; cursor: zoom-in" src="13.png" alt="Image">
		</div>
		<p style="font-style: italic; text-align: center;">Рисунок 13. Два разных способа отрисовки шестилучевой звезды.</p>
		<p>Можно решить, что быстрее отрисовать два полигона, чем 10. Однако в данном случае это скорее всего неверно, потому что пиксели в центре звезды будут отрисовываться дважды. Это явление называется перерисовкой (overdraw). По сути оно означает, что пиксели перерисовываются больше одного раза. Перерисовка естественным образом возникает во всём процессе рендеринга. Например, если персонаж частично скрыт колонной, то он будет отрисован целиком, несмотря на то, что колонна перекрывает часть персонажа. Некоторые движки используют сложные алгоритмы, позволяющие избегать отрисовку объектов, невидимых на конечном изображении, но это трудная задача. Центральному процессору часто труднее выяснить, что не нужно отрисовывать, чем GPU отрисовать это.</p>
		<p>Работая художником, вы должны смириться с тем, что от перерисовки не избавиться, но хорошей практикой является удаление поверхностей, которые нельзя увидеть. Если вы сотрудничаете с командой разработчиков, то попросите добавить в игровой движок режим отладки, в котором всё становится прозрачным. Это упростит поиск спрятанных полигонов, которые можно удалить.</p>

		<h3>Реализация ящика на полу:</h3>
		<p>На рисунке 14 показана простая сцена: стоящий на полу ящик. Пол состоит всего из двух треугольников, а ящик состоит из 10 треугольников. Перерисовка в этой сцене показана красным цветом.</p>
		<div style="text-align: center;">
			<img style="max-width: 100%; width: 85%; height: 85%; margin-top: 25px; cursor: zoom-in" src="14.png" alt="Image">
		</div>
		<p style="font-style: italic; text-align: center;">Рисунок 14. Стоящий на полу ящик.</p>
		<p>В этом случае GPU отрисует часть пола пол ящиком, несмотря на то, что его не будет видно. Если бы вместо это мы создали под ящиком дыру в полу, то получили бы большее количество полигонов, но намного меньше перерисовки, как видно из рисунка 15.</p>
		<div style="text-align: center;">
			<img style="max-width: 100%; width: 85%; height: 85%; margin-top: 25px; cursor: zoom-in" src="15.png" alt="Image">
		</div>
		<p style="font-style: italic; text-align: center;">Рисунок 15. Дыра под ящиком, позволяющая избежать перерисовки.</p>
		<p>В подобных случаях всё зависит от вашего выбора. Иногда стоит уменьшить количество полигонов, получив взамен перерисовку. В других ситуациях стоит добавить полигонов, чтобы избежать перерисовки. Ещё один пример: две показанные ниже фигуры являются одинаково выглядящими мешами поверхности с торчащими из неё остриями. В первом меше (рисунок 16) острия расположены на поверхности.</p>
		<div style="text-align: center;">
			<img style="max-width: 100%; width: 85%; height: 85%; margin-top: 25px; cursor: zoom-in" src="16.png" alt="Image">
		</div>
		<p style="font-style: italic; text-align: center;">Рисунок 16. Острия расположены на поверхности.</p>
		<p>Во втором меше на рисунке 17 в поверхностью под остриями прорезаны отверстия, чтобы уменьшить объём перерисовки.</p>
		<div style="text-align: center;">
			<img style="max-width: 100%; width: 85%; height: 85%; margin-top: 25px; cursor: zoom-in" src="17.png" alt="Image">
		</div>
		<p style="font-style: italic; text-align: center;">Рисунок 17. Под остриями вырезаны отверстия.</p>
		<p>В этом случае для вырезания отверстий было добавлено множество полигонов, часть из которых имеет узкую форму. К тому же поверхность перерисовки, от которой мы избавились, не очень велика, поэтому в данном случае эта техника неэффективна.</p>
		<p>Представьте, что вы моделируете дом, стоящий на земле. Чтобы создать его, вы можете или оставить землю без изменений, или вырезать под дом отверстие в земле. Перерисовки больше в случае, когда под домом не вырезана дыра. Однако выбор зависит от геометрии и точки обзора, с которой дом будет видеть игрок. Если нарисовать под основанием дома землю, то это создаст большой объём перерисовки, если войти внутрь дома и взглянуть вниз. Однако разница не будет особо большой, если вы будете смотреть на дом с самолёта. Лучше всего в таком случае иметь в игровом движке режим отладки, делающий поверхности прозрачными, чтобы вы могли видеть то, что отрисовывается под видимыми игроку поверхностями.</p>

		<h3>Когда у Z-буферов возникает Z-конфликт:</h3>
		<p>Когда GPU отрисовывает два накладывающихся друг на друга полигона, то как он определяет, какой из них находится поверх другого? Первые исследователи компьютерной графики потратили много времени на исследование этой проблемы. Эд Кэтмэлл (который позже стал президентом Pixar и Walt Disney Animation Studios) написал статью, в которой изложил десять различных подходов к решению этой задачи. В одной части статьи он замечает, что решение этой задачи будет тривиальным, если у компьютеров будет достаточно памяти для хранения одного значения глубины на пиксель. В 1970-х и 1980-х это был очень большой объём памяти. Однако сегодня так работает большинство GPU: такая система называется Z-буфером.</p>
		<p>Z-буфер (также известный как буфер глубин) работает следующим образом: с каждым пикселем связывается значение его глубины. Когда оборудование отрисовывает объект, оно вычисляет, как далеко от камеры отрисовывается пиксель. Затем оно проверяет значение глубины уже существующего пикселя. Если он дальше от камеры, чем новый пиксель, то новый пиксель отрисовывается. Если уже имеющийся пиксель ближе к камере, чем новый, то новый пиксель не отрисовывается. Такой подход решает множество проблем и работает, даже если полигоны пересекаются.</p>
		<div style="text-align: center;">
			<img style="max-width: 100%; width: 85%; height: 85%; margin-top: 25px; cursor: zoom-in" src="0.png" alt="Image">
		</div>
		<p style="font-style: italic; text-align: center;">Рисунок 18. Пересекающиеся полигоны, обработанные буфером глубин.</p>
		<p>Однако Z-буфер не обладает бесконечной точностью. Если две поверхности находятся почти на одном расстоянии от камеры, то это сбивает GPU с толку и он может случайным образом выбрать одну из поверхностей, как это показано на рисунке 19.</p>
		<div style="text-align: center;">
			<img style="max-width: 100%; width: 85%; height: 85%; margin-top: 25px; cursor: zoom-in" src="18.png" alt="Image">
		</div>
		<p style="font-style: italic; text-align: center;">Рисунок 19. У поверхностей на одинаковой глубине появляются проблемы с отображением.</p>
		<p>Это называется Z-конфликтом (Z-fighting) и выглядит очень забагованно. Часто Z-конфликты становятся тем хуже, чем дальше поверхность от камеры. Разработчики движков могут встраивать в них исправления, позволяющие сгладить эту проблему, но если художник создаёт достаточно близкие и накладывающиеся друг на друга полигоны, то проблема всё равно может возникать. Ещё одним примером может служить стена с висящим на ней постером. Постер находится почти на той же глубине от камеры, что и стена за ним, поэтому очень высок риск Z-конфликтов. Решение заключается в том, чтобы вырезать в стене отверстие под постером. При этом также снизится объём перерисовки.</p>
		<div style="text-align: center;">
			<img style="max-width: 100%; width: 85%; height: 85%; margin-top: 25px; cursor: zoom-in" src="19.png" alt="Image">
		</div>
		<p style="font-style: italic; text-align: center;">Рисунок 20. Пример Z-конфликта накладывающихся друг на друга полигонов.</p>
		<p>В крайних случаях Z-конфликт может возникнуть, даже когда объекты касаются друг друга. На рисунке 20 показан ящик на полу, и поскольку мы не вырезали в полу под ящиком отверстие, z-буфер может быть сбит с толку рядом с ребром, где пол встречается с ящиком.</p>

		<h3>Использование вызовов отрисовки:</h3>
		<p>GPU стали чрезвычайно быстрыми — настолько быстрыми, что ЦП могут за ними и не успевать. Так как GPU по сути предназначены для выполнения одной задачи, их гораздо проще заставить работать быстро. Графика по своей природе связана с вычислением множества пикселей, поэтому можно создать оборудование, вычисляющих множество пикселей параллельно. Однако GPU отрисовывает только то, что ему приказывает отрисовывать ЦП. Если ЦП не может достаточно быстро «кормить» GPU данными, то видеокарта будет простаивать. Каждый раз, когда ЦП приказывает GPU что-то отрисовать, называется вызовом отрисовки. Простейший вызов отрисовки состоит из отрисовки одного меша, в том числе одного шейдера и одного набора текстур.</p>
		<p>Представьте медленный процессор, способный передавать 100 вызовов отрисовки за кадр, и быстрый GPU, который может отрисовывать по миллиону полигонов за кадр. В таком случае идеальный вызов отрисовки (draw call) может отрисовывать 10 000 полигонов. Если ваши меши состоят всего из 100 полигонов, то GPU сможет отрисовывать только 10 000 полигонов за кадр. То есть 99% времени GPU будет простаивать. В таком случае мы можем запросто увеличить количество полигонов в мешах, ничего при этом не потеряв.</p>
		<p>То, из чего состоит вызов отрисовки, и затраты на него сильно зависят от конкретных движков и архитектур. Некоторые движки могут объединить в один вызов отрисовки множество мешей (выполнить их батчинг, batch), но все меши при этом обязаны будут иметь одинаковый шейдер, или могут иметь другие ограничения. Новые API наподобие Vulkan и DirectX 12 разработаны специально для решения этой проблемы при помощи оптимизации того, как программа общается с графическим драйвером, увеличивая таким образом количество вызовов отрисовки, которые можно передать за один кадр.</p>
		<p>Если ваша команда пишет собственный движок, то спросите у разработчиков движка, какими ограничениями обладают вызовы отрисовки. Если вы используете готовый движок наподобие Unreal или Unity, то выполните бенчмарки производительности, чтобы определить пределы возможностей движка. Вы можете обнаружить, что можно увеличить количество полигонов, не вызывая при этом снижения скорости.</p>

		<h3>Заключение:</h3>
		<p>Надеюсь, эта статья послужит вам хорошим введением, способным помочь в понимании различных аспектов производительности рендеринга. В GPU разных производителей всё реализовано немного по-своему. Существует множество оговорок и особых условий, связанных с конкретными движками и аппаратными платформами. Всегда поддерживайте открытый диалог с программистами рендеринга, чтобы использовать их рекомендации в своём проекте.</p>

		<h3>Об авторе:</h3>
		<p>
			Эскил Стеенберг (Eskil Steenberg) — независимый разработчик игр и инструментов, он работает и консультантом, и над независимыми проектами. Все скриншоты сделаны в активных проектах с помощью инструментов, разработанных Эскилом.
		</p>
		<hr>
	</div>

	<footer>
		<HR>
		<div class="footinfo">
			<p class="footinfo_text">Copyright ©2024|Все права защищены</p>
		</div>
	</footer>
</body>
</html>